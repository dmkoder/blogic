[{"content":"Introduction This post aims to present, analyze, and solve the four challenges from the programming contest held at the International Conference on Logic Programming (2024). Short specifications of the problems are elaborated on and accompanied by graphical visualizations for better understanding. The solutions of the challenges will be presented in two formalisms: IDP (scientific paper1, technical manual2), and Answer Set Programming (ASP) (scientific paper3, documnetaiotn page).\nAbout the contest The Programming Contest at the 2024 International Conference on Logic Programming was organized by Prof. Martin Gebser. Participants faced four challenges, each of which could be solved using any declarative programming language, such as Prolog, ASP, or IDP, within a time limit of one and a half hours. The competition was conducted in teams of up to three members.\nProblems Challenge 1: Gates to truth Problem description from the assignment:\nIn this problem, we are given the layout of a Boolean circuit with unary and binary gates, yet we have to decide which logical operations the gates should perform. For each unary gate, we have to choose between the identity function and negation, and between logical AND and OR for the binary gates. A partial specification requires specific output values for some truth assignments of the input variables, while the output can be arbitrary for the remaining truth assignments.\nThe following figure illustrates the problem by displaying the given layout of the logical circuit (first block), four entries of desired input/output values for the circuit (second block), and finally the unique assignment of the functionalities of each of the gates in the circuit such that entries from the previous block are satisfied (third block).\nWe should focus on the underlying knowledge of this domain in order to provide a good declarative solution to this problem. The main building block of this domain is the logical gate. These are further composed into logical circuits and constrained by certain entities that are provided. However, the main law in this example is the law of the behavior of different logical gates. The following illustration depicts the different logical gates and how they map their input variables to the output in terms of logical operations (block one), and provides a tabular definition for each of the logical operations (block two).\nNotice that for the logical OR gate, if any of the input values is 1, the result is 1, and similarly for the AND gate, if any of the input values is 0, the result is 0. These are called absorbing values and will be important for the ASP encoding.\nTaking everything into account, the idea is to declaratively define (formally specify) the behavior of each of the gates by refining their output in terms of the input variables. Additionally, this definition should support multiple entries. Finally, we should be able to search for gate functionalities given the layout of the circuit (i.e., connections of inputs and outputs of different gates) and the list of entries.\nIDP3 solution The first step towards the solution is to consider the format of the input. We are given specification of the Boolean circuit in a Prolog stile fact list using the following predicates:\n\\(variable/1\\) - set of logical variables that are input of the circuit. \\(result/1\\) - variable representing the output of the circuit. \\(unary/1\\) - set of unary gates. \\(binary/1\\) - set of binary gates. \\(input/3\\) - set of input variables of a gate per slot (if unary only one, if binary then two). \\(output/2\\) - output variable per gate. \\(entry/3\\) - value of input variables per iteration. \\(value/3\\) - value of the output variable per iteration. Here (\\(/n\\)) denotes the arity of the predicate. Expected result is \\(function/2\\) predicate assigning functionalities to gats. Since every gate has exactly one functionality we model this predicate as function. This ontology is represented by the vocabulary block in the solution code.\nThe idea is to find functionalities of all the gates in the circuit such that given samples of values for input and output variables are satisfied. These samples are represented by predicates \\(entry/3\\) and \\(value/3\\), where entry conatins values of input variables per saple and value of the output variable.\nTo solw the problem we should model the behaviour of the circuit depending on the gates functionalities. The behaviour of the circuite is modeled in a composite way as definition of the output of each gate in terms of it\u0026rsquo;s imput. For example, let input of a binary gate \\(G_1\\) be variables \\(x_1\\) and \\(x_2\\), and output variable \\(x_3\\), then:\nIf gate is OR, value of \\(x_3\\) is logical \u0026ldquo;or\u0026rdquo; of values \\(x_1\\) and \\(x_2\\). If gate is AND, value of \\(x_3\\) is logical \u0026ldquo;and\u0026rdquo; of values \\(x_1\\) and \\(x_2\\). Similar for the unary gates. As all gates are connected, this definition will define the value of the output of the circuit in terms of the input variables. Further, our definition should take into account different samples, i.e., value of output is defined per iteration.\nNote that even though the goal is to find functionalities of the gates, we are defining the value of variables in terms of gates. This is because IDP system can reason in any direction, and hence can be used to find functionalities of gates such that partialy specified values of variables are sensible (i.e., satisfying the value definition).\nThe main code of the solution is contained in the \u0026ldquo;Theory\u0026rdquo; block in the two definitions:\n\u0026ldquo;Definition of Gate operations\u0026rdquo; defines the logical operations negation (\\(neg\\)), conjunction (\\(and\\)), and disjunction (\\(or\\)). \u0026ldquo;Definition of a cValue of a variable\u0026rdquo; defines the computed value (\\(cValue\\)) of each variable (input or output of any gate) per iteration. Following is the code containing the full solution of the problem. It is possible to run the code in the online editor by clicking \u0026ldquo;Try in online editor!\u0026rdquo;.\nGates-to-truth.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nASP solution The idea behind the ASP solution is similar to the one presented above.\nThe first two rules serve only to populate the unary predicate gate using the given information about unary and binary.\nBinary predicate $\\mathit{function}$ represents the functionality of a gate. The first rule expresses that it can be chosen arbitrarily to be 0; this is expressed with the choice rule (one with the {function(G,0)} in the head). The second rule expresses that the function of a gate is 1 if it is not 0. In this way, the binary predicate function is actually functional (has at most one value per gate). The choice rule opens the predicate and allows the function to take an arbitrary assignment.\nPredicate $\\mathit{propagate}$ captures the propagation of values through the circuit per iteration. The first rule simply copies the values given for the input variables. The second rule captures the unary gates, inverting their value if needed. This is captured by the absolute value of an input value subtracted by the value of the gate. Since the identity gate is 0, it will make no difference, and the negation gate will reduce the value by 1, which, combined with the absolute value, indeed inverts the input value. Because the AND gate is represented by 0 and the OR gate by 1, the third propagation rule derives that the output of any gate takes the value of the gate itself if one of its inputs has that value. This rule exploits the absorbing elements of Boolean algebra: if one of the inputs to the AND gate is false, regardless of the other input, the output is false; similarly, for the OR gate, if one of the inputs is true, the output is true. The last rule covers the last case for the binary gates; if both inputs of a gate have the same value, then that value is the output for the corresponding gate. This is 0 for the OR gate, 1 for the AND gate.\nGates-to-truth.lp Author: Martin Gebser\nChallenge 2: Tile them all Problem description from the assignment:\nConsider a rectangular \\(4 \\times 5\\) grid such that each of its cells contains a number: \\(0, 1, 2,\\) or \\(3\\). The goal is to group horizontally or vertically adjacent cells into ten disjoint pairs such that all ten of the combinations \\(\\{0, 1, 2, 3\\} \\times \\{0, 1, 2, 3\\}\\) are represented by a pair, also called tile.\nThe following figure illustrates the problem. On the left is presented an example input matrix, in the middle are pairs of all possible combinations of numbers, on the right these pairs are uniquely identified in the matrix.\nTo solve this problem, we will declaratively specify what it means for two cells to be a pair in the matrix, and then add the constraint that each possible pair has to exist.\nSolwing the problem with IDP3 The format of the input for this problem is the Prolog stile fact list specifying the value for each cell in the matrix:\n\\(cell/3\\) - set of values per cell, where cell is specified as X and Y The expected resul (pairs of cells) is represented with two binary functions \\(pairx/2:\\) and \\(pairy/2:\\) mapping cells to X and Y coordinate respectevly. Intuitevly, given cell \\((X,Y)\\) its pair is represented as \\((pairx(X,Y), pairy(X,Y))\\).\nFollowing is the code containing the full solution of the problem. The solution contains axioms that are explained with comments. It is possible to run the code in the online editor by clicking \u0026ldquo;Try in online editor!\u0026rdquo;.\nTile-them-all.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Bart Bogaerts\nASP solution The ASP solution is conceptually similar to the IDP solution presented above. The main difference is that ASP needs a choice rule to open the tile predicate for different possibilities, while this is implicit in the semantics of IDP. The code below is the ASP solution, and the lines are explained with comments.\nTile-them-all.lp Author: Martin Gebser\nChallenge 3: Area fifty won Problem description from the assignment:\nConsider a \\(5 \\times 5\\) grid such that some of its cells contain positive numbers and the remaining cells are empty. The goal is to partition the grid into as many disjoint areas as there cells with positive numbers, where each area consists of exactly one cell with a positive number \\(N\\) and \\(N − 1\\) empty cells. Moreover, the cells of each area must form a connected region, i.e., there is a path via horizontally or vertically adjacent neighbors between any two cells belonging to the same area.\nThe problem is illustrated in the following figure. On the left, we can see the input \\(5 \\times 5\\) table where each cell contains a number (\\(0\\) cells are empty). In the middle is a table with identified cells that represent the roots of the partitions. Finally, the table on the right represents the unique solution where each cell with number \\(n \\neq 0\\) is associated with exactly \\(n\\) other cells all mutually reachable (this is represented by the same color of the cells around cells with the number).\nThe main property of this problem is the definition of what it means for a group of cells to be connected in an island, i.e., each cell in the group is reachable from each other. Once this property is formalized, all that is needed is to specify constraints that in each island there is one non-zero cell and that size of the island is exactly that number.\nSolwing the problem with IDP3 The format of the input for this problem is the Prolog stile fact list specifying the numbers for each cell in the matrix:\n\\(\\mathit{cell}/3\\) - number per cell, where cell is specified as Row and Col(umn) The expected resul (partitioning of cells) is represented with unary function \\(\\mathit{inAria}/1:\\) mapping positions to areas.\nTo make the formalization more natural we use the following extra types, predicates, and functions:\n\\(\\mathit{Pos}\\) - A type representing positions and constructed as the set of pairs from existing types \\(\\mathit{Row}\\) and \\(\\mathit{Col}\\). \\(\\mathit{content}/1:\\) - Function mapping positions to the number, functionalization of relation \\(\\mathit{cell}/3\\). \\(\\mathit{adjacent}/2\\) - Relation of neighbouring cells (Manhattan distance at most 1) \\(\\mathit{path}/3\\) - The relation between two points and area. It holds true iff the second position is reachable from the first only through the cells of the same area. Following is the code containing the full solution of the problem. The solution contains axioms that are explained with comments. It is possible to run the code in the online editor by clicking \u0026ldquo;Try in online editor!\u0026rdquo;.\nArea-fifty-won.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Robbe Van den Eede\nASP solution Area-fifty-won.lp Author: Martin Gebser\nChallenge 4: Fence for fans Problem description from the assignment:\nConsider a \\(W \\times H\\) grid of width W and height H such that, for each cell \\(c\\), a non-negative cost \\(cost(c)\\) and a (possibly negative) reward \\(reward(c)\\) is given. The goal is to set up a fence, forming a non-empty and non-simple cycle, which must not include any cell with a negative reward (\\(reward(c) \u003c 0\\) is not permitted for cells \\(c\\) belonging to the cycle) and maximizes the following quality function:\n\\[\\sum_{\\text{cell } c \\text{ belongs to the cycle}} (reward(c) - cost(c))\\]Moreover, given limits on the length of the cycle, i.e., the number of contained cells, and the budget for setting up the cycle, i.e., the sum of costs \\(cost(c)\\) over the cells \\(c\\) belonging to the cycle, must not be exceeded.\nThe following figure is presenting an input table (top left) with it components reward (top right) and cost (bottom left) scores. The same figure provides an example of a non-empty cycle (bottom right), the arrows are there to help us ilustrate how such a cycle can be defined.\nThe core of this problem is definition of a valid non-empty non-trivial cycle of fences, the remaining of the probelm is about adding couple of constraints and searching for an optimal solution. A valid cycle is a set of cells that can be grouped into pairs of cells forming a linear closed path. This means that such a path has no branching nor merging, and every cell in the path has to be reachable from every other cell. On the figure above, bottom right ilustration depicts the cycle by colored cells and the described relation with arrows.\nThe following figure presents two optimal solution for the given input matrix from the previous figure. The purple cycle (top right) has total score of \\(8\\) (\\(20\\) reward minus \\(12\\) cost, recall that each cell cost \\(1\\) in this example). The orange cycle (bottom left) has total score of \\(8\\) too (\\(18\\) reward minus \\(10\\) cost). Both solutions are valid.\nSolwing the problem with IDP3 The format of the input for this problem is the Prolog stile fact list specifying the reward/cost for each cell in the matrix:\n\\(\\mathit{reward}/3\\) - reward per cell, where cell is specified as Row and Col(umn) \\(\\mathit{cost}/3\\) - cost per cell, where cell is specified as Row and Col(umn) Additionally we are provided with width and height of the matrix and length and budget for the fence (in form of the unary predicates).\n\\(\\mathit{width}/1\\) - width of the matrix \\(\\mathit{height}/1\\) - height of the matrix \\(\\mathit{length}/1\\) - maximum length of the fences \\(\\mathit{budget}/1\\) - maximum cost of the fences The expected resul (set of cells forming the fence) is represented with unary predicate \\(\\mathit{fence}/1\\). As helping predicates we have \\(\\mathit{adjacent}/2\\) relation, \\(\\mathit{next}/2\\) relation to model the cycle (arrows from the first figure), and \\(\\mathit{path}/2\\) relation to express transitive closure of the \\(\\mathit{next}\\) relation.\nFollowing is the code containing the full solution of the problem. The solution contains axioms that are explained with comments. It is possible to run the code in the online editor by clicking \u0026ldquo;Try in online editor!\u0026rdquo;.\nFence-for-fans.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nASP solution The following is the ASP solution, explained with inline comments.\nFence-for-fans.lp Author: Martin Gebser\nConclusion Through the years, the ICLP Programming Contest was dominated by ASP and Prolog formalisms for solving the problems. In this post, we presented how these problems can be solved with the IDP3 system. We also provided ASP solutions for comparison and diversity.\nWe conclude that the IDP3 system proved to be suitable for modeling and solving problems from the 2024 ICLP Programming Contest. In the end, we point to two important observations. First, IDP3 provides a natural way to model domains independently of the specific problem. A good example is the first challenge, where the defined concept is given as input, and we search for parameters of the definition. This power of the IDP3 system comes from the precise model semantics of the language, allowing clear and declarative specifications of the domain. Secondly, it is important to mention that the challenges were on the edge of the computational capacity of the IDP3 system. Hence, for some problems, finding the solution can take up to a few minutes (e.g., the last problem). On the other side, ASP is capable of solving these problems more efficiently.\nThe source code for all examples is available in this Git repository.\nDe Cat, B., Bogaerts B., Bruynooghe M., Janssens G., Denecker M. (2018). Predicate logic as a modeling language: the IDP system. In Declarative Logic Programming: Theory, Systems, and Applications (pp. 273\u0026ndash;323).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKU Leuven Knowledge Representation and Reasoning research group (2020), The IDP framework reference manual.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEiter T., Ianni G., Krennwallner T. (2009). Answer set programming: A primer. In Lecture Notes in Computer Science (pp. 40\u0026ndash;110).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2026-01-10T00:00:00Z","image":"https://blogic.ink/p/programming_contest_iclp_2024/undraw_competition.svg","permalink":"https://blogic.ink/p/programming_contest_iclp_2024/","title":"Programming Contest - International Conference on Logic Programming (2024)"},{"content":"At the 17th International Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR 2024), the paper titled A Sequent Calculus for Generalized Inductive Definitions by Robbe Van den Eede, Robbe Van Biervliet, and Marc Denecker won the Best Paper Award. For bLogic.ink, Robbe Van den Eede contributed an article that provides an accessible explanation of the paper.\nWhat is the paper about? We have introduced a formal proof system to reason in a logic that extends classical logic with a very general notion of inductive definition, covering not only the standard monotone inductive definitions but also inductive definitions over a well-founded order and iterated inductive definitions. The proof system is a so-called sequent calculus, which is a certain style of proof system developed by Gentzen. In a sequent calculus, proofs take the form of trees consisting of sequents, which are essentially implications. Sequent calculi are a popular style of proof systems because they offer a systematic approach to prove statements and are theoretically elegant.\nWhy it is important? Many of the most fundamental objects in mathematics are defined constructively through inductive definitions. Therefore, inductive definitions have received a lot of attention in mathematical logic. A few simple examples of inductive definitions in mathematics are included below:\nExample. The natural numbers can be defined as follows:\n$0$ is a natural number; $x+1$ is a natural number if $x$ is a natural number. Example. The even numbers can be defined as follows:\n$0$ is an even number; $x+1$ is an even number if $x$ is not an even number. Example. Let $G$ be a graph with node set $V$ and edge set $E$. The transitive closure $T$ of $G$ can be defined as follows. For all $x,y \\in V$:\n$(x,y) \\in T$ if $(x,y) \\in E$; $(x,y) \\in T$ if there exists a $z \\in V$ such that $(x,z) \\in T$ and $(z,y) \\in T$. Example. The satisfaction relation $\\models$ in propositional logic is a binary relation between structures $\\mathcal{I}$ (seen as sets of propositional constants) and propositional formulas $\\varphi$. It is defined as follows:\n$\\mathcal{I} \\models p$ if $p \\in \\mathcal{I}$; $\\mathcal{I} \\models \\varphi \\land \\psi$ if $\\mathcal{I} \\models \\varphi$ and $\\mathcal{I} \\models \\psi$; $\\mathcal{I} \\models \\lnot \\varphi$ if $\\mathcal{I} \\not\\models \\varphi$. Inductive definitions consist of rules that dictate how to construct the defined object. Repeatedly applying these rules (possibly an infinite number of times) results in the defined object. Inductive definitions appear in various forms. For instance, the definitions of the natural numbers and the transitive closure of a graph are monotone, as they add objects to the defined set based on the presence of other objects in the set. This is not the case for the definitions of the even numbers and the satisfaction relation. For instance, the fact that $2$ is an even number is derived from the fact that $1$ is not an even number. For these definitions, one must be careful not to apply rules prematurely. One may only derive that $x+1$ is even once it is certain that $x$ is not even, since otherwise one could derive that $1$ is even, for instance. To guarantee a safe rule application, one should follow the well-founded order (an order is well-founded if it has no infinite descending chains) imposed by the definitional rules. For the even number definition, this well-founded order is the natural order on the natural numbers, and for the satisfaction relation, this is the subformula order on propositional formulas. The transitive closure definition does not impose a well-founded order on its elements.\nInductive definitions thus appear in different forms, such as monotone inductive definitions, inductive definitions over a well-founded order and so-called iterated inductive definitions. A uniform formalisation of all these kinds of inductive definitions and the underlying construction processes is provided by the logic FO(ID). FO(ID) is an extension of classical first-order logic with a syntactic construct to express inductive definitions in an intuitive rule-based format. More specifically, inductive definitions are represented in FO(ID) as sets of definitional rules. These are expressions of the form \\[\\forall \\bar{x}: P(\\bar{t}) \\leftarrow \\varphi ,\\] where $\\bar{x}$ is a tuple of variables, $P(\\bar{t})$ an atom called the head of the rule, and $\\varphi$ a first-order formula called the body of the rule. The natural language definitions from before can be formalised in FO(ID) as follows:\nExample. The natural numbers can be defined as a unary predicate $N$ by the following definition in FO(ID): \\[ \\left\\{ \\begin{array}{l} N(0)\\\\ \\forall x: N(x+1) \\leftarrow N(x) \\end{array} \\right\\} \\] Example. The even numbers can be defined as a unary predicate $E$ by the following definition in FO(ID): \\[ \\left\\{ \\begin{array}{l} E(0)\\\\ \\forall x: E(x+1) \\leftarrow \\lnot E(x) \\end{array} \\right\\} \\] Example. The transitive closure of a graph $G = (V,E)$ can be defined as a binary predicate $T$ by the following definition in FO(ID): \\[ \\left\\{ \\begin{array}{l} \\forall x,y: T(x,y) \\leftarrow E(x,y)\\\\ \\forall x,y: T(x,y) \\leftarrow \\exists z: T(x,z) \\land T(z,y) \\end{array} \\right\\} \\] Here we assume the universe to be the node set $V$.\nExample. The satisfaction relation can be defined as a binary predicate $\\mathit{Sat}$ by the following definition in FO(ID): \\[ \\left\\{ \\begin{array}{l} \\forall i, f: \\mathit{Sat}(i,p) \\leftarrow \\mathit{Member}(p,i)\\\\ \\forall i, f, g: \\mathit{Sat}(i, and(f,g)) \\leftarrow \\mathit{Sat}(i, f) \\land \\mathit{Sat}(i, g)\\\\ \\forall i, f: \\mathit{Sat}(i, not(f)) \\leftarrow \\lnot \\mathit{Sat}(i, f) \\end{array} \\right\\} \\] Here the variable $i$ represents a structure and the variables $f$ and $g$ represent formulas. The predicate $\\mathit{Member}/2$ represents the element relation $\\in$, and the (constructor) functions $and/2$ and $not/1$ send formulas to their conjunctions and negations respectively.\nThe inductive definition format of FO(ID) was inspired by the formalism of logic programming, a computational logic based on rules with negation in the body. In fact, some have even pointed to inductive definitions as a declarative foundation of logical and functional programming languages.\nThe constructive kind of information behind inductive definitions is not only of importance in mathematics, but also in broad applications of formal specification languages and declarative programming languages. In the field of Knowledge Representation and Reasoning, people think about good formal languages to specify information, and how these specifications can be used to solve problems. In the early days of Artificial Intelligence, the traditional knowledge representation language was first-order logic. However, first-order logic has some serious limitations when it comes to its expressivity. Strikingly, first-order logic is incapable of expressing some elementary notions such as the set of natural numbers and the transitive closure of a graph. To enhance the expressivity of a logic, one can add additional language constructs to the logic. One powerful language construct in this regard is that of inductive definitions. Besides mathematical structures, inductive definitions can be used to model various kinds of complex systems. Two examples are listed below.\nExample. Consider a graph in which edges can be \u0026lsquo;activated\u0026rsquo; at each time point. Once activated, an edge remains active until a path of active edges emerges from a fixed node $a$ to a fixed node $b$. If this happens, all edges become inactive again. The state of the active edges can be modeled by defining a predicate $\\mathit{Active}/3$, together with an auxiliary predicate $\\mathit{ActivePath}/3$, in terms of a predicate $\\mathit{MakeActive}/3$, as follows: \\[ \\left\\{ \\begin{array}{l} \\forall n,m,t: \\mathit{Active}(n,m,t+1) \\leftarrow \\mathit{MakeActive}(n,m,t) \\land \\lnot \\mathit{ActivePath}(a,b,t)\\\\ \\forall n,m,t: \\mathit{Active}(n,m,t+1) \\leftarrow \\mathit{Active}(n,m,t) \\land \\lnot \\mathit{ActivePath}(a,b,t)\\\\ \\forall n,m,t: \\mathit{ActivePath}(n,m,t) \\leftarrow \\mathit{Active}(n,m,t)\\\\ \\forall n,m,p,t: \\mathit{ActivePath}(n,p,t) \\leftarrow \\mathit{ActivePath}(n,m,t) \\land \\mathit{ActivePath}(m,p,t) \\end{array} \\right\\} \\] Here the variables $n$, $m$ and $p$ represent nodes of the graph, and $t$ represents a time point (interpreted as a natural number). The predicates should be read as follows: An atom of the form $\\mathit{MakeActive}(n,m,t)$ expresses that the edge $(n,m)$ is activated at time point $t$. The value of this predicate is given. An atom of the form $\\mathit{Active}(n,m,t+1)$ expresses that the edge $(n,m)$ is active at time point $t$, and an atom of the form $\\mathit{ActivePath}(n,m,t)$ expresses that there is a path of active edges from node $n$ to node $m$ at time point $t$. The value of these predicates are determined by the value of $\\mathit{MakeActive}$. Through variations, this abstract example can be converted into real-world examples, such as the creation of electric circuits that burn through once a short circuit has been formed, or the construction of towers that collapse after a threshold height/weight has been exceeded.\nExample. Consider a system in which users may or may not have access to a certain file. A user has access if it is the owner $o$, or if it is granted access by a user with access, but not blocked by a user with access. This scenario can be modeled by an FO(ID) definition of a predicate $\\mathit{Access}/1$, in terms of predicates $\\mathit{Grants}/2$ and $\\mathit{Blocks}/2$: \\[ \\left\\{ \\begin{array}{l} \\mathit{Access}(o)\\\\ \\forall u : \\mathit{Access}(u) \\leftarrow \\exists v (\\mathit{Access}(v) \\land \\mathit{Grants}(v,u)) \\land \\lnot \\exists v (\\mathit{Access}(v) \\land \\mathit{Blocks}(v,u)) \\end{array} \\right\\} \\] Already quite some proof systems have been developed for inductive definitions. However, none of these proof systems cover inductive definitions as generally as FO(ID). Negation in a definition, if allowed at all, is only allowed in a stratified way. This means that one can assign a level $\\ell(Q) \\in \\mathbb{N}$ to every predicate $Q$ in the definition such that for every definitional rule $\\forall \\bar{x}: P(\\bar{t}) \\leftarrow \\varphi$ and any predicate $Q$ in $\\varphi$, $\\ell(P) \\geq \\ell(Q)$, and furthermore $\\ell(P) \u0026gt; \\ell(Q)$ if $Q$ appears negatively in $\\varphi$.\nStratification excludes a lot of interesting and useful definitions. For example, the even number definition is not stratified, as there is no level $\\ell(E) \\in \\mathbb{N}$ for $E$ such that $\\ell(E) \u0026gt; \\ell(E)$. Notice that it is still possible to define the even numbers in the existing frameworks via a positive definition (i.e., without negation), for instance by replacing the second rule by $\\forall x:E(x+2)\\leftarrow E(x)$. However, this is not does not work for any non-stratified definition. For the same reason, the definitions of the satisfaction relation, the active edges, and the access relation are not stratified and hence not allowed in the existing frameworks.\nThe reason why the existing frameworks impose stratification on their definitions is because, if one is not careful, such uncontrolled negative dependencies may result in \u0026lsquo;bad\u0026rsquo; definitions. For instance, the definition \\[\\left\\{ \\begin{array}{l} P \\leftarrow \\lnot P \\end{array} \\right\\} \\] cannot attribute a truth value (true or false) to $P$, as this truth value would contradict itself. The stratification condition guarantees that definitions are always ‘good’, in the sense that they always lead to well-constructed objects. Nevertheless, there are a lot of interesting non-stratified definitions that still lead to well-constructed objects. Furthermore, one may argue that even \u0026lsquo;bad\u0026rsquo; definitions such as $\\bigl\\{ P \\leftarrow \\lnot P \\bigr\\}$ are interesting in their own right, as they can be linked to philosophical paradoxes. In fact, this very definition can be seen as a formalisation of the well-known liar paradox, which is the sentence “This sentence is false”, by viewing $P$ as the truth value of the sentence. Our work fills a gap in the scientific literature by providing a formal proof system that can reason about these general non-stratified definitions.\nFO(ID) thus allows us to represent very rich kinds of information that range from mathematical structures to logic programs, complex dynamical systems and even philosophical paradoxes. Strikingly, it reveals connections between multiple scientific disciplines that appear unrelated at first sight. The sequent calculus that we introduced for FO(ID) enables us to produce formal proofs about general inductive definitions and the rich kinds of information that can be captured with them.\nProofs are very special objects, as they establish with certainty that a theorem is correct and, moreover, they explain in detail why the theorem is correct. Formal proof systems serve as the basis of proof assistants, which are computer tools that can verify the correctness of proofs, and that can help humans in finding new proofs. On one side, these proof assistants are used by mathematicians to formalise their complicated pen-and-paper proofs and to check that they are in fact correct, or even to aid them in proving new theorems. On another side, proof assistants are used in the formal verification of software and hardware systems.\nAnother use of proof systems lies in proof logging, which is a technique used in combinatorial solvers to produce, alongside the output to a given problem, a proof that this output is correct. The generated proof is then verified by a separate proof checker, after which the correctness of the produced output is guaranteed. The importance of proof logging grows with the progress in solver technology. This progress makes solvers more efficient, but also more complicated, which sometimes results in the production of faulty outputs. Our proof system can be used to implement proof logging as well as a proof checker for solvers that use (non-stratified) inductive definitions, such as MinisatID.\nHow is it done? To obtain our proof system for general inductive definitions, we extended an existing proof system for inductive definitions by Brotherston and Simpson, based on the principle of mathematical induction. By mathematical induction, we mean a proof technique that is commonly taught in secondary school to prove theorems about the natural numbers. In it simplest form, mathematical induction for the natural numbers says the following: to prove that a certain property $P$ holds for every natural number $n$, it suffices to prove that the property holds for $0$ (the base case), and that if the property holds for a given number $x$, it also holds for $x+1$ (the induction step). In a formal proof system, this proof technique corresponds to the following inference rule: \\[ \\begin{array}{c} P(0) \\qquad P(x) \\Rightarrow P(x+1) \\\\ \\hline N(n) \\Rightarrow P(n) \\end{array} \\] The formulas above the line are called the premises, and the formula below the line is called the conclusion of the rule. The inference rule says that if the base case and the induction step for $P$ (the premises) hold, then any natural number $n$ has property $P$ (the conclusion). Note that the premises of this inference rule are similar to the rules in the definition of the natural number predicate $N$ above. This is no coincidence. An alternative way of interpreting the natural number definition is by seeing $N$ as the smallest set that satisfies its defining rules. The inference rule above can also be read as saying that if $P$ is a set that satisfies the defining rules of $N$, then $N$ must be a subset of $P.$\nSometimes the above method does not suffice, as it may be necessary to strengthen the induction hypothesis. For example, the following result cannot be proven with the above method:\nFact. For every natural number $n$, the sum of the first $n$ odd numbers is a perfect square. (A perfect square is a number that is equal to the square $m^2$ of a natural number $m$.)\nWe can, however, use the above method to prove the following stronger result:\nFact. For every natural number $n$, the sum of the first $n$ odd numbers is equal to $n^2$.\nThus, to prove a certain property $P$ of the natural numbers, one generally needs to find another property for which the method of mathematical induction works and which implies $P$. This stronger property is called the induction hypothesis. There is no general method to find a suitable induction hypothesis, so applying this proof technique usually requires some creativity. Letting $F$ denote the induction hypothesis, this proof technique corresponds to the following inference rule:\n\\[ \\begin{array}{c} F(0) \\qquad F(x) \\Rightarrow F(x+1) \\qquad F(n) \\Rightarrow P(n) \\\\ \\hline N(n) \\Rightarrow P(n) \\end{array} \\]The above proof method does not only work for the natural numbers, but in fact for any object that can be defined inductively, or at least through a positive definition (i.e., without negation). The proof system of Brotherston and Simpson does not support definitions with negation, which is very restrictive compared to FO(ID). Adding negation to definitions makes things significantly trickier. As an example, consider the following definition of the odd number predicate $O$: \\[ \\left\\{ \\begin{array}{l} \\forall x: O(x+1) \\leftarrow \\lnot O(x) \\end{array} \\right\\} \\] It differs from the even number definition in that it does not have a rule saying that $0$ is odd. If we were to straightforwardly extend the inference rule we had for the natural numbers to this definition, it would look as follows: \\[ \\begin{array}{c} \\lnot F(x) \\Rightarrow F(x+1) \\qquad F(n) \\Rightarrow P(n) \\\\ \\hline O(n) \\Rightarrow P(n) \\end{array} \\] The left premise says that the induction hypothesis $F$ satisfies the defining rule of $O$, and the right premise says that it implies the property $P$ that we want to prove for the odd numbers. This is not a good inference rule, however, as it is not sound, meaning that it can derive false statements! For instance, letting $F$ and $P$ be the even number predicate $E$, we could derive that any odd number is also an even number, which is of course wrong. The underlying reason is that an induction hypothesis generally holds for more objects than those contained in the defined predicate. Hence, the negation of an induction hypothesis generally holds for less objects than those not contained in the defined predicate. Therefore, the negation of an induction hypothesis is too strong of an assumption for non-members of the defined predicate.\nOur solution to this problem is surprisingly easy. We simply replace the formula $\\lnot F(x)$ in the left premise by the formula $\\lnot O(x)$: \\[ \\begin{array}{c} \\lnot O(x) \\Rightarrow F(x+1) \\qquad F(n) \\Rightarrow P(n) \\\\ \\hline O(n) \\Rightarrow P(n) \\end{array} \\] As a recapitulation, $O$ represents the inductively defined concept in this example, $P$ is a property to be proven about the inductively defined concept $O$, and $F$ is the induction hypothesis, a property that should imply $P$. This inference rule allows us to prove all kinds of properties of odd numbers, such as the fact that every odd number is the successor (or predecessor) of an even number, for example.\nOur solution may seem naïve, but we have shown that this proof technique is sound for general non-stratified definitions, and it appears strong enough to prove many theorems about non-stratified definitions.\nWhat is next? So far, we have only presented the proof system itself, applied it to a few examples of non-stratified definitions, and shown that it is sound. Soundness is a minimal property for a proof system to have, as it means that its inference rules can only derive true statements. A first direction for further research is therefore to show extra theoretical properties that give further insight into the system, e.g., in how powerful the system is.\nA second idea would be to develop a cyclic proof system for non-stratified definitions, extending another proof system by Brotherston and Simpson. In a cyclic proof system, proofs no longer take the form of trees but of general graphs, which may contain cycles. This makes the structure of proofs more complex, but it trades off against the complexity of the inference rules themselves. In particular, cyclic proofs can circumvent the principle of mathematical induction and therefore, it is no longer necessary to creatively guess a good induction hypothesis.\nThird, we can extend the obtained proof system to a more powerful system that can reason about even more complex information by incorporating additional language constructs, such as partial functions, modal operators, aggregates, etc.\nFinally, our sequent calculus can be used as the basis of a proof assistant that can aid humans in proving theorems about general inductive definitions, and it can be used to extend combinatorial solvers that use inductive definitions such as MinisatID with proof logging algorithms.\nIn conclusion, we have established a promising framework for doing formal proofs about general inductive definitions, providing certainty and explainability for complex forms of knowledge.\n","date":"2025-10-29T00:00:00Z","image":"https://blogic.ink/p/a-sequent-calculus-for-general-inductive-definitions/undraw_proof-tree.svg","permalink":"https://blogic.ink/p/a-sequent-calculus-for-general-inductive-definitions/","title":"A Sequent Calculus for General Inductive Definitions"},{"content":"In this article, we’ll illustrate how knowledge‑representation systems built on first‑order logic can tackle practical challenges. As a concrete example, we’ll model a simple autonomous‑vehicle controller that dynamically compensates for wind variations while staying firmly on course. This kind of controller one can usually find in autonomous pilot systems (E.g. drones). The controller we analyze is originally described in the article Boyer, 19901 by Boyer, Green, and Moore. This example is also formalized using the Imandra system, and here we reproduce the same results in the more lean modeling language.\nThe primary goal of this post is to show how to model a simple autonomous vehicle controller and then prove some major safety properties about it using the good old language of first-order logic. On our way there, we first explain the simple vehicle controller and safety properties about it. After that, we provide a short overview of the IDP knowledge base system (based on first-order logic). Finally, we explain how this system can be used to prove properties about vehicle controller. We close this discussion with a short conclusion.\nIntroduction Simple vehicle controller Here we provide a short explanation of the simple vehicle controller system. One can imagine that such a controller is in charge of controlling a drone. In this example controller is taking care of the wind; basically, we want a drone to stay relatively stable in a windy situation without any pilot assistance. We introduce a few constraints and assumptions in order to make the system easier and feasible for our purposes. However, note that imposing these constraints does not affect the generality of our system.\nWe restrict the system to only one space dimension (y-axis). I.e., the drone can move only in one dimension, the other two dimensions are fixed. We abstract over time by seeing the system as a sequence of discreet time points. The vehicle can move with a certain velocity in the positive or negative direction of the y-axis. The wind can blow with a particular speed (in the positive or negative direction of the y-axis). The drone reads the wind speed at each time point. Wind speed cannot change more than one unit between two time points. The controller can change the velocity of the vehicle at any time point for an arbitrary value. We use following parameters to represent the system:\nWind speed - (windSpeed) Vehicle position - (vehiclePosition) Vehicle speed - (vehicleSpeed) Delta wind - (deltaWind or windChange) When we say that the system is in state (ws,vp,vs) we mean that wind speed = ws, vehicle position = vp, vehicle speed = vs. E.g. (0,0,0) is the state where all three values are zero.\nController properties Modeling a controller is one problem, but verifying its properties is a totally another problem. Usually in this kind of system we want to ensure certain safety properties, hence we want to provide formal proofs that the controller will fulfill them. Before we prove desired properties we have to state them. Here we express some properties that we would like our controller to have:\nTheorem [Wind balancing] If the vehicle starts at the initial state (0,0,0), then the controller guarantees the vehicle never strays farther than three units from the y-axis (I.e. -3 ≤ vehiclePosition ≤ 3).\nTheorem [Constant wind] If the wind ever becomes constant for at least four sampling intervals, then the vehicle returns to the zero point on the y-axis and stays there as long the wind remains constant.\nIn general, it is difficult to automatically prove such theorems, and we later transform these theorems into simpler statements by performing certain transformations. The resulting new simpler statements we call invariants. We use this name to indicate that some property is not changing over time (I.e., always holds).\nIDP system To model this simple dynamic system of the vehicle controller and to prove theorems about it, we are going to use IDP system.\nIDP is a knowledge Base System (KB-system) for the FO(·) language. A Knowledge Base system is a system that supports multiple forms of inferences for the same Knowledge Base. FO(·) is an extension of first-order logic (FO) with types, aggregates, inductive definitions, bounded arithmetic, partial functions, etc. — KU Leuven - DTAI - Knowledge Representation and Reasoning Group website\nFor more details you can check the following links:\nKU Leuven - KRR group FO(.) Language IDP system IDPz3 system (IDP using Z3 solver) Also you can read more in the article (De Cat, 2018)2.\nThe main differences between IDP3 and IDPz3 regarding this example are:\nIDPz3 supports infinite domains while IDP3 does not. IDP3 provides build-in methods for proving invariants, more on this topic can be found in the article of Bogaerts et al. (Bogaerts, 2014)3. The IDPz3 theorem prover supports arithmetics. Since none of the systems (at the moment) provides all the features, we will present a (partial) solution in both systems. The plan is to support automated proving of invariants in the new version of IDPz3.\nIDP3 solution In this section, we first provide the IDP3 linear time calculus theory that formalizes the dynamic system of a simple vehicle controller. Next, we explain how one can use this knowledge base to make interactive simulations, which can be useful to gain some basic idea about controller properties. In the end, we elaborate on how to prove invariants about the simple vehicle controller using this system.\nFormalizing the Simple Vehicle Controller In the following specification, we model the simple vehicle controller dynamic system. An IDP model has several components: a vocabulary introducing the domain, a theory expressing domain knowledge, a structure (partially) instantiating the types and relations in the domain, and a procedure initiating some form of inference. As simulating the system and proving invariants about it requires a somewhat different vocabulary and different theories, we split the vocabulary and the theory. The knowledge base is structured as follows:\nLTC vocabulary [Simple vehicle controller]:\n\\(type \\text{ } Time\\) - A set of natural numbers describing time points. \\(Start : () \\rightarrow Time\\) - A constant representing the time point when the simulation starts. \\(Next : Time \\not\\rightarrow Time\\) - A function mapping a time point to the next time point. We use \\(\\not\\rightarrow\\) to denote that \\(Next\\) is partial function. This is the case because \\(Time\\) is a finite subset of natural numbers. \\(windSpeed : Time \\rightarrow Int\\) - A function mapping time points to the wind speed. \\(vehiclePos : Time \\rightarrow Int\\) - A function mapping time points to the vehicle position. \\(vehicleSpeed : Time \\rightarrow Int\\) - A function mapping time points to the vehicle speed. \\(windChange : Time \\rightarrow Int\\) - A function mapping time points to the wind change. \\(sgn : Int \\rightarrow Int\\) - A function mapping integers to their sign. Note that windSpeed, vehiclePos, vehicleSpeed, and windChange are all represented by integers. Type \\(Int\\) is built-in. LTC vocabulary [Good state] (extending vocabulary of Simple vehicle controller):\n\\(GS : Int \\times Int\\) - Predicate describing a set of reachable states from the state (0,0,0). The first attribute of GS is representing the vehicle position and the second represents the sum of wind and vehicle speed. We need notion of a good state for proving invariants. You can find more about good states in (Boyer, 1990)1. Theory [Time]:\nTime theory symply defines the starting point as the minimum of type Time and the function next to map time points t to time points t+1. Theory [Simple vehicle controller]:\nThis is the central theory in our example, this is the knowledge we have about the system, and about the controller. Additionally in this theory we specify the sign function. Theory [Good state]:\nThe good state theory defines the GS predicate by enumerating the set of good states. Note that here we do not discuss how to get these states. In the following code you can find the sketched knowledge base.\nSimple_vehicle_controller-Formalization.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nSimulating the system Since we have modeled a dynamic temporal system, it can be useful to simulate it interactively. Simulation is quite useful since it provides a way of debugging the system. While formalizing our system we can use simulation to check whether our system behaves in the way we want. Once we are done with formalization we can use simulation also to explain the behavior of the system to other people. From the other side we can use simulations to test different ideas of controllers while we are searching for a good design.\nHere we provide a simulate method, which takes a theory and a structure as an input. Basic idea is to take a set of possible actions at the given moment and ask the user to select one of the states to be propagated. Looping over this process is actually a simulation of the dynamic system. In this particular case at each time point there is only one parameter to be selected by the user, and that is wind change.\nSimple_vehicle_controller-Simulation.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nFor more information about the particular methods of the IDP system please check the (IDP manual, 2020)4. For more details on reasoning in linear time calculus check (Bogaerts, 2014)3.\nProving invariant The IDP3 system provides an automated way of proving invariants for linear time calculus theories. Here we demonstrate how this automated way of proving invariants can be used on Theorem 1. The system provides two options for proving invariants: (1) using its theorem prover, (2) using model expansion. For both cases, we need to specify initial states to be added to the theory, and the invariant to be proven. For the theorem prover, we do not need a structure, since it will try to prove the invariant generally, i.e., independant of a structure. But for the model expansion approach, we have to provide s structure, since it is a finite model generator, hence we have to limit our types. Once we have all of these, we can simply use the isinvariant builtin method.\nHere we provide that the initial state is (0,0,0) and we attempt to prove the invariant that says that the system is always in a good state. We also provide structures interpreting the given types.\nSimple_vehicle_controller-Theorem-1.idp \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nDue to the arithmetics used in the theory, the theorem prover used in IDP3 will fail to prove the invariant of this theory. Unfortunately in this particular case, due to the very large search space, the method based on model expansion will most likely run out of resources and never finish.\nThe method used to prove the first part of the second theorem is not built-in into IDP3 so we are going to skip this part and go straight to the IDPz3. The idea of proving such theorems would be the same in the IDP3 system, but it does not support infinite domains.\nIDPz3 solution Here we provide solutions for verifying properties of the earlier described dynamic system of the simple vehicle controller. Since IDPz3 still does not natively support the isinvariant procedure, here we do the transformation manually.\nTheorem 1 As it is explained in the main article, the first theorem is simplified by introducing the notion of a good state \\(GS : Int \\times Int\\). Basically, the theorem is transformed to the statement that the system is always in a good state. \\[\\forall t : GS(vehiclePos(t), windSpeed(t) + vehicleSpeed(t))\\] Here we provide proof by induction over time:\nBase case For the base case, we describe the system as it is initially, so we drop all the rules describing transition. Additionally we express the negation of the invariant as a part of the theory. That is because we are basically going to search for a counterexample of the invariant for the base case. The inference method we use is model_expand which searches for the models of the theory. If our invariant holds then there is no such model.\nNote that we do not need time anymore, since our theory is now only about one single state. So, we replace the functions describing the systems with adequate constants.\nSimple_vehicle_controller-Theorem_1-Base_case.idpz3 \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nObviously, the theory about the base case is unsatisfiable.\nInduction case In the induction case, we specify the system in two consecutive time points (we will call them initial and step) with the functional dependencies between them. So, we again introduce constants to describe the system in these two time points, and remove the time. The idea is the same, we try to find a model where our invariant does not hold for the step state with the assumption that it does hold at the initial state. If there is no such model, our invariant holds.\nIn the induction case we simply prove that whenever the system is in a good state, it will also be in a good state after a step is made. \\[\\forall t : GS(vehiclePos(t), windSpeed(t) + vehicleSpeed(t)) \\Rightarrow GS(vehiclePos(t+1), windSpeed(t+1) + vehicleSpeed(t+1))\\] Simple_vehicle_controller-Theorem_1-Induction_case.idpz3 \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nHere IDPz3 proves that the above theory is unsatisfiable.\nTheorem 2 The second theorem is also simplified using the notion of a good state. First, we prove that the vehicle gets back to the course after four consecutive time points of constant wind. After that, we use the same idea of induction to prove that the vehicle remains there as long as the wind remains constant.\nBack to the course First, we define transitions between five consecutive time points (indexed with 0..4). Next, we express the assumptions that the system is initially in a good state and that wind never changes. Now we want to prove that, at the last time point, the system is in the good state (0,0). This is a stronger result than we normally need, we just need to prove that the vehicle is at position 0. But we prove the stronger theorem since we will need it later to prove that the vehicle remains at the same position. We use the same idea as before and try to find a counterexample of the described theory (that is why the final result is negated in the theory).\nSimple_vehicle_controller-Theorem_2-Back_to_the_course.idpz3 \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nVehicle remains at the course In order to prove that the vehicle remains at the course as long as the wind is constant, we are going to use induction. Basically, we want to prove that if the system is in a good state (0,0) it will remain at that state as long as the wind does not change. In order to create a single state formula (invariant) that we want to prove we move the if part (when the system is in a good state (0,0)) to the theory. By doing this we obtain the invariant: \u0026ldquo;system is always in a good state (0,0)\u0026rdquo;. It is trivial that this invariant is initially satisfied so we move directly to the induction case.\nSimple_vehicle_controller-Theorem_2-Remain_at_the_course.idpz3 \u0026#x1f680; \u0026nbsp; Try Online! Author: Đorđe Marković\nConclusion In this short exercise, we show how a simple vehicle controller can be modeled using the IDP system. Furthermore, we demonstrate how to prove some basic safety properties about such a controller. We also demonstrate other possibilities and perks of using this approach (like simulation).\nBoyer, R. S. (1990). The use of a formal simulator to verify a simple real time control program. In Beauty Is Our Business. Springer.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDe Cat, B. a. (2018). Predicate logic as a modeling language: the IDP system. In Declarative Logic Programming: Theory, Systems, and Applications (pp. 273\u0026ndash;323).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBogaerts, B. a. (2014). Simulating Dynamic Systems Using Linear Time Calculus Theories. Theory and Practice of Logic Programming.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKU Leuven Knowledge Representation and Reasoning research group (2020), The IDP framework reference manual\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-29T00:00:00Z","image":"https://blogic.ink/p/simple-vehicle-controller/undraw_drone.svg","permalink":"https://blogic.ink/p/simple-vehicle-controller/","title":"Simple vehicle controller"}]