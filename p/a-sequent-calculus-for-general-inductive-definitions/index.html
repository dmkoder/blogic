<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Robbe Van den Eede"><title>A Sequent Calculus for General Inductive Definitions</title><link rel=canonical href=https://blogic.ink/p/a-sequent-calculus-for-general-inductive-definitions/><link rel=stylesheet href=/scss/style.min.86591c898bd806857815fbb8c47e8d3fed97c133b78e83d9bfc27b164dd0aa2b.css><meta property='og:title' content="A Sequent Calculus for General Inductive Definitions"><meta property='og:description' content="Robbe Van den Eede"><meta property='og:url' content='https://blogic.ink/p/a-sequent-calculus-for-general-inductive-definitions/'><meta property='og:site_name' content='bLogic.ink'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Proofs'><meta property='article:tag' content='Inductive definitions'><meta property='article:tag' content='Sequent calculus'><meta property='article:published_time' content='2025-10-29T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-29T00:00:00+00:00'><meta property='og:image' content='https://blogic.ink/p/a-sequent-calculus-for-general-inductive-definitions/undraw_proof-tree.png'><meta name=twitter:title content="A Sequent Calculus for General Inductive Definitions"><meta name=twitter:description content="Robbe Van den Eede"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://blogic.ink/p/a-sequent-calculus-for-general-inductive-definitions/undraw_proof-tree.png'><link rel="shortcut icon" href=/favicon.png><script data-goatcounter=https://blogicink.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/logo_hu_c689cef34c81ba2d.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>bLogic.ink</a></h1><h2 class=site-description>Ink and Think!</h2></div></header><ol class=menu-social><li><a href=https://github.com/dmkoder/blogic target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://mastodon.social/@blogicink target=_blank title=Mastodon rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round" id="svg2"><path stroke="none" d="M0 0h24v24H0z" fill="none" id="path1"/><path class="a" d="m20.595927 10.122926c0 3.052575-.474293 4.096329-1.406729 4.970717-1.889896 1.772775-6.918223 1.63502-6.918223 1.63502-1.145837.01397-2.2906993-.07229-3.4215044-.257804.0.0-.5492173 3.616673 6.3922264 1.843067l-.07049 2.068678c-1.0578.141463-11.1253317 3.863404-11.1980155-9.10095l-.02731-1.158972c0-3.0525774.024393-4.1376974 1.4067269-5.6638878C7.0920186 2.5381659 12.27098 2.7830433 12.27098 2.7830433s3.367188-.1592097 5.583133.7859932c.532254.2270319.998092.517781 1.334895.8897577 1.382241 1.5263375 1.406728 2.6114575 1.406728 5.6638878" id="path1-0" style="fill:none;stroke-width:1.34995;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1"/><path class="a" d="M12.270975 11.542921V8.6271249A2.2703352 2.2703352.0 0010.00059 6.3567892v0A2.2703352 2.2703352.0 007.730255 8.6271249v4.7055001" id="path2-2" style="fill:none;stroke-width:1.34995;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1"/><path class="a" d="m12.270975 8.6271249a2.2703352 2.2703352.0 012.270383-2.2703357v0a2.2703352 2.2703352.0 012.270335 2.2703357v4.7055001" id="path3" style="fill:none;stroke-width:1.34995;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round" id="svg2"><path stroke="none" d="M0 0h24v24H0z" fill="none" id="path1"/><circle cx="12.084137" cy="11.833251" r="9.5972548" stroke-linecap="round" stroke-linejoin="round" id="circle1" style="stroke-width:2;stroke-dasharray:none"/><path d="m12.084139 10.766887v6.39817" stroke-linecap="round" stroke-linejoin="round" id="path1-1" style="stroke-width:2;stroke-dasharray:none"/><path d="M11.817547 7.5678015V6.5014414h.533178v1.0663601z" stroke-linecap="round" stroke-linejoin="round" id="path2" style="stroke-width:2;stroke-dasharray:none"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#what-is-the-paper-about>What is the paper about?</a></li><li><a href=#why-it-is-important>Why it is important?</a></li><li><a href=#how-is-it-done>How is it done?</a></li><li><a href=#what-is-next>What is next?</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/a-sequent-calculus-for-general-inductive-definitions/><img src=/p/a-sequent-calculus-for-general-inductive-definitions/undraw_proof-tree.svg loading=lazy alt="Featured image of post A Sequent Calculus for General Inductive Definitions"></a></div><div class=article-details><header class=article-category><a href=/categories/theory/ style=background-color:#60c3aa;color:#fff>Theory</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/a-sequent-calculus-for-general-inductive-definitions/>A Sequent Calculus for General Inductive Definitions</a></h2><h3 class=article-subtitle>Robbe Van den Eede</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-10-29T00:00:00Z>Oct 29, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>16 minute read</time></div></footer></div></header><section class=article-content><p>At the 17th International Conference on Logic Programming and Non-Monotonic Reasoning (<a class=link href=https://lpnmr2024.demacs.unical.it/ target=_blank rel=noopener>LPNMR 2024</a>), the paper titled <a class=link href=https://link.springer.com/chapter/10.1007/978-3-031-74209-5_3 target=_blank rel=noopener><em>A Sequent Calculus for Generalized Inductive Definitions</em></a> by Robbe Van den Eede, Robbe Van Biervliet, and Marc Denecker won the <a class=link href=https://ai.kuleuven.be/news/robbe-van-den-eede-wins-best-paper-award-at-lpnmr-2024 target=_blank rel=noopener>Best Paper Award</a>. For <a class=link href=/>bLogic.ink</a>, Robbe Van den Eede contributed an article that provides an accessible explanation of the paper.</p><h2 id=what-is-the-paper-about>What is the paper about?</h2><p>We have introduced a <strong>formal proof system</strong> to reason in a logic that extends classical logic with a very <strong>general notion of inductive definition</strong>, covering not only the standard monotone inductive definitions but also inductive definitions over a well-founded order and iterated inductive definitions. The proof system is a so-called <strong>sequent calculus</strong>, which is a certain style of proof system developed by Gentzen. In a sequent calculus, proofs take the form of <strong>trees</strong> consisting of <strong>sequents</strong>, which are essentially implications. Sequent calculi are a popular style of proof systems because they offer a systematic approach to prove statements and are theoretically elegant.</p><p><img src=/p/a-sequent-calculus-for-general-inductive-definitions/figures/proof-tree.png width=1026 height=652 srcset="/p/a-sequent-calculus-for-general-inductive-definitions/figures/proof-tree_hu_a8eaa372b392d7d9.png 480w, /p/a-sequent-calculus-for-general-inductive-definitions/figures/proof-tree_hu_e53e7fc0b5b73d0.png 1024w" loading=lazy alt="Figure 1. In a sequent calculus, proofs take the form of trees. Through logical inference steps, a complex statement (at the root of the tree) is reduced to trivial statements (at the leafs of the tree)." class=gallery-image data-flex-grow=157 data-flex-basis=377px></p><h2 id=why-it-is-important>Why it is important?</h2><p>Many of the most fundamental objects in mathematics are defined constructively through <strong>inductive definitions</strong>. Therefore, inductive definitions have received a lot of attention in mathematical logic. A few simple examples of inductive definitions in mathematics are included below:</p><blockquote><p><em>Example.</em> The <strong>natural numbers</strong> can be defined as follows:</p><ul><li>$0$ is a natural number;</li><li>$x+1$ is a natural number if $x$ is a natural number.</li></ul></blockquote><blockquote><p><em>Example.</em> The <strong>even numbers</strong> can be defined as follows:</p><ul><li>$0$ is an even number;</li><li>$x+1$ is an even number if $x$ is not an even number.</li></ul></blockquote><blockquote><p><em>Example.</em> Let $G$ be a graph with node set $V$ and edge set $E$. The <strong>transitive closure</strong> $T$ of $G$ can be defined as follows. For all $x,y \in V$:</p><ul><li>$(x,y) \in T$ if $(x,y) \in E$;</li><li>$(x,y) \in T$ if there exists a $z \in V$ such that $(x,z) \in T$ and $(z,y) \in T$.</li></ul></blockquote><p><img src=/p/a-sequent-calculus-for-general-inductive-definitions/figures/transitive_closure/transitive_closure.gif width=2480 height=1181 srcset="/p/a-sequent-calculus-for-general-inductive-definitions/figures/transitive_closure/transitive_closure_hu_462033becff288fc.gif 480w, /p/a-sequent-calculus-for-general-inductive-definitions/figures/transitive_closure/transitive_closure_hu_ab4dcc2ea04e71c5.gif 1024w" loading=lazy alt="Figure 2. A graph (green) and its transitive closure (green + orange)." class=gallery-image data-flex-grow=209 data-flex-basis=503px></p><blockquote><p><em>Example.</em> The <strong>satisfaction relation</strong> $\models$ in propositional logic is a binary relation between structures $\mathcal{I}$ (seen as sets of propositional constants) and propositional formulas $\varphi$. It is defined as follows:</p><ul><li>$\mathcal{I} \models p$ if $p \in \mathcal{I}$;</li><li>$\mathcal{I} \models \varphi \land \psi$ if $\mathcal{I} \models \varphi$ and $\mathcal{I} \models \psi$;</li><li>$\mathcal{I} \models \lnot \varphi$ if $\mathcal{I} \not\models \varphi$.</li></ul></blockquote><p>Inductive definitions consist of <strong>rules that dictate how to construct the defined object</strong>. Repeatedly applying these rules (possibly an infinite number of times) results in the defined object. Inductive definitions appear in various forms. For instance, the definitions of the natural numbers and the transitive closure of a graph are <strong>monotone</strong>, as they add objects to the defined set based on the <strong>presence</strong> of other objects in the set. This is not the case for the definitions of the even numbers and the satisfaction relation. For instance, the fact that $2$ is an even number is derived from the fact that $1$ is <em>not</em> an even number. For these definitions, one must be careful not to apply rules prematurely. One may only derive that $x+1$ is even once it is certain that $x$ is not even, since otherwise one could derive that $1$ is even, for instance. To guarantee a safe rule application, one should follow the <em>well-founded order</em> (an order is <em>well-founded</em> if it has no infinite descending chains) imposed by the definitional rules. For the even number definition, this well-founded order is the natural order on the natural numbers, and for the satisfaction relation, this is the subformula order on propositional formulas. The transitive closure definition does not impose a well-founded order on its elements.</p><p>Inductive definitions thus appear in <strong>different forms</strong>, such as monotone inductive definitions, inductive definitions over a well-founded order and so-called iterated inductive definitions. A uniform formalisation of all these kinds of inductive definitions and the underlying construction processes is provided by the logic <strong>FO(ID)</strong>. FO(ID) is an extension of classical first-order logic with a syntactic construct to express inductive definitions in an intuitive rule-based format. More specifically, inductive definitions are represented in FO(ID) as sets of <em>definitional rules</em>. These are expressions of the form</p>\[\forall \bar{x}: P(\bar{t}) \leftarrow \varphi ,\]<p>where $\bar{x}$ is a tuple of variables, $P(\bar{t})$ an atom called the <em>head</em> of the rule, and $\varphi$ a first-order formula called the <em>body</em> of the rule. The natural language definitions from before can be formalised in FO(ID) as follows:</p><blockquote><p><em>Example.</em> The natural numbers can be defined as a unary predicate $N$ by the following definition in FO(ID):</p>\[ \left\{ \begin{array}{l}
N(0)\\
\forall x: N(x+1) \leftarrow N(x)
\end{array} \right\}
\]</blockquote><blockquote><p><em>Example.</em> The even numbers can be defined as a unary predicate $E$ by the following definition in FO(ID):</p>\[ \left\{ \begin{array}{l}
E(0)\\
\forall x: E(x+1) \leftarrow \lnot E(x)
\end{array} \right\}
\]</blockquote><blockquote><p><em>Example.</em> The transitive closure of a graph $G = (V,E)$ can be defined as a binary predicate $T$ by the following definition in FO(ID):</p>\[ \left\{ \begin{array}{l}
\forall x,y: T(x,y) \leftarrow E(x,y)\\
\forall x,y: T(x,y) \leftarrow \exists z: T(x,z) \land T(z,y)
\end{array} \right\}
\]<p><br>Here we assume the universe to be the node set $V$.</p></blockquote><blockquote><p><em>Example.</em> The satisfaction relation can be defined as a binary predicate $\mathit{Sat}$ by the following definition in FO(ID):</p>\[ \left\{ \begin{array}{l}
\forall i, f: \mathit{Sat}(i,p) \leftarrow \mathit{Member}(p,i)\\
\forall i, f, g: \mathit{Sat}(i, and(f,g)) \leftarrow \mathit{Sat}(i, f) \land \mathit{Sat}(i, g)\\
\forall i, f: \mathit{Sat}(i, not(f)) \leftarrow \lnot \mathit{Sat}(i, f)
\end{array} \right\}
\]<p>Here the variable $i$ represents a structure and the variables $f$ and $g$ represent formulas. The predicate $\mathit{Member}/2$ represents the element relation $\in$, and the (constructor) functions $and/2$ and $not/1$ send formulas to their conjunctions and negations respectively.</p></blockquote><p>The inductive definition format of FO(ID) was inspired by the formalism of <strong>logic programming</strong>, a computational logic based on rules with negation in the body. In fact, some have even pointed to inductive definitions as a declarative <em>foundation</em> of logical and functional programming languages.</p><p>The constructive kind of information behind inductive definitions is not only of importance in mathematics, but also in broad applications of formal specification languages and declarative programming languages. In the field of <strong>Knowledge Representation and Reasoning</strong>, people think about good formal languages to specify information, and how these specifications can be used to solve problems. In the early days of Artificial Intelligence, the traditional knowledge representation language was first-order logic. However, first-order logic has some serious limitations when it comes to its expressivity. Strikingly, first-order logic is incapable of expressing some elementary notions such as the set of natural numbers and the transitive closure of a graph. To enhance the expressivity of a logic, one can add additional language constructs to the logic. One powerful language construct in this regard is that of <strong>inductive definitions</strong>. Besides mathematical structures, inductive definitions can be used to model various kinds of complex systems. Two examples are listed below.</p><blockquote><p><em>Example.</em> Consider a graph in which edges can be &lsquo;activated&rsquo; at each time point. Once activated, an edge remains active until a path of active edges emerges from a fixed node $a$ to a fixed node $b$. If this happens, all edges become inactive again. The state of the active edges can be modeled by defining a predicate $\mathit{Active}/3$, together with an auxiliary predicate $\mathit{ActivePath}/3$, in terms of a predicate $\mathit{MakeActive}/3$, as follows:</p>\[ \left\{ \begin{array}{l}
\forall n,m,t: \mathit{Active}(n,m,t+1) \leftarrow \mathit{MakeActive}(n,m,t) \land \lnot \mathit{ActivePath}(a,b,t)\\
\forall n,m,t: \mathit{Active}(n,m,t+1) \leftarrow \mathit{Active}(n,m,t) \land \lnot \mathit{ActivePath}(a,b,t)\\
\forall n,m,t: \mathit{ActivePath}(n,m,t) \leftarrow \mathit{Active}(n,m,t)\\
\forall n,m,p,t: \mathit{ActivePath}(n,p,t) \leftarrow \mathit{ActivePath}(n,m,t) \land \mathit{ActivePath}(m,p,t)
\end{array} \right\}
\]<p>Here the variables $n$, $m$ and $p$ represent nodes of the graph, and $t$ represents a time point (interpreted as a natural number). The predicates should be read as follows: An atom of the form $\mathit{MakeActive}(n,m,t)$ expresses that the edge $(n,m)$ is activated at time point $t$. The value of this predicate is given. An atom of the form $\mathit{Active}(n,m,t+1)$ expresses that the edge $(n,m)$ is active at time point $t$, and an atom of the form $\mathit{ActivePath}(n,m,t)$ expresses that there is a path of active edges from node $n$ to node $m$ at time point $t$. The value of these predicates are determined by the value of $\mathit{MakeActive}$. Through variations, this abstract example can be converted into real-world examples, such as the creation of electric circuits that burn through once a short circuit has been formed, or the construction of towers that collapse after a threshold height/weight has been exceeded.</p></blockquote><p><img src=/p/a-sequent-calculus-for-general-inductive-definitions/figures/temporal_graph/temporal_graph.gif width=2480 height=1181 srcset="/p/a-sequent-calculus-for-general-inductive-definitions/figures/temporal_graph/temporal_graph_hu_bad0a9c610012d3a.gif 480w, /p/a-sequent-calculus-for-general-inductive-definitions/figures/temporal_graph/temporal_graph_hu_5c1e60af4e512e1a.gif 1024w" loading=lazy alt="Figure 3. As soon as a path of active edges from a to b emerges, all edges become inactive again." class=gallery-image data-flex-grow=209 data-flex-basis=503px></p><blockquote><p><em>Example.</em> Consider a system in which users may or may not have access to a certain file. A user has access if it is the owner $o$, or if it is granted access by a user with access, but not blocked by a user with access. This scenario can be modeled by an FO(ID) definition of a predicate $\mathit{Access}/1$, in terms of predicates $\mathit{Grants}/2$ and $\mathit{Blocks}/2$:</p>\[ \left\{ \begin{array}{l}
\mathit{Access}(o)\\
\forall u : \mathit{Access}(u) \leftarrow \exists v (\mathit{Access}(v) \land \mathit{Grants}(v,u)) \land \lnot \exists v (\mathit{Access}(v) \land \mathit{Blocks}(v,u))
\end{array} \right\}
\]</blockquote><p>Already quite some proof systems have been developed for inductive definitions. However, <strong>none of these proof systems cover inductive definitions as generally as FO(ID)</strong>. Negation in a definition, if allowed at all, is only allowed in a <em>stratified</em> way. This means that one can assign a <strong>level</strong> $\ell(Q) \in \mathbb{N}$ to every predicate $Q$ in the definition such that for every definitional rule $\forall \bar{x}: P(\bar{t}) \leftarrow \varphi$ and any predicate $Q$ in $\varphi$, $\ell(P) \geq \ell(Q)$, and furthermore $\ell(P) > \ell(Q)$ if $Q$ appears negatively in $\varphi$.</p><p>Stratification excludes a lot of interesting and useful definitions. For example, the even number definition is not stratified, as there is no level $\ell(E) \in \mathbb{N}$ for $E$ such that $\ell(E) > \ell(E)$. Notice that it is still possible to define the even numbers in the existing frameworks via a positive definition (i.e., without negation), for instance by replacing the second rule by $\forall x:E(x+2)\leftarrow E(x)$. However, this is not does not work for any non-stratified definition. For the same reason, the definitions of the satisfaction relation, the active edges, and the access relation are not stratified and hence not allowed in the existing frameworks.</p><p>The reason why the existing frameworks impose stratification on their definitions is because, if one is not careful, such uncontrolled negative dependencies may result in &lsquo;bad&rsquo; definitions. For instance, the definition</p>\[\left\{ \begin{array}{l}
P \leftarrow \lnot P
\end{array} \right\}
\]<p>cannot attribute a truth value (true or false) to $P$, as this truth value would contradict itself. The stratification condition guarantees that definitions are always ‘good’, in the sense that they always lead to well-constructed objects. Nevertheless, there are a lot of interesting non-stratified definitions that still lead to well-constructed objects. Furthermore, one may argue that even &lsquo;bad&rsquo; definitions such as $\bigl\{ P \leftarrow \lnot P \bigr\}$ are interesting in their own right, as they can be linked to <strong>philosophical paradoxes</strong>. In fact, this very definition can be seen as a formalisation of the well-known <strong>liar paradox</strong>, which is the sentence “This sentence is false”, by viewing $P$ as the truth value of the sentence. Our work fills a gap in the scientific literature by providing a <strong>formal proof system that can reason about these general non-stratified definitions</strong>.</p><p>FO(ID) thus allows us to represent very <strong>rich kinds of information</strong> that range from mathematical structures to logic programs, complex dynamical systems and even philosophical paradoxes. Strikingly, it reveals connections between multiple scientific disciplines that appear unrelated at first sight. The sequent calculus that we introduced for FO(ID) enables us to produce <strong>formal proofs</strong> about <strong>general inductive definitions</strong> and the rich kinds of information that can be captured with them.</p><p><img src=/p/a-sequent-calculus-for-general-inductive-definitions/figures/proof_importance.png width=794 height=495 srcset="/p/a-sequent-calculus-for-general-inductive-definitions/figures/proof_importance_hu_2ca3d34b294ecd2d.png 480w, /p/a-sequent-calculus-for-general-inductive-definitions/figures/proof_importance_hu_a28f5bd6d4a65dbb.png 1024w" loading=lazy alt="Figure 4. Proofs provide absolute certainty and explainability for the correctness of theorems." class=gallery-image data-flex-grow=160 data-flex-basis=384px></p><p><strong>Proofs</strong> are very special objects, as they establish with <strong>certainty that a theorem is correct</strong> and, moreover, they <strong>explain in detail why the theorem is correct</strong>. Formal proof systems serve as the basis of <strong>proof assistants</strong>, which are computer tools that can verify the correctness of proofs, and that can help humans in finding new proofs. On one side, these proof assistants are used by mathematicians to formalise their complicated pen-and-paper proofs and to check that they are in fact correct, or even to aid them in proving new theorems. On another side, proof assistants are used in the <strong>formal verification</strong> of software and hardware systems.</p><p>Another use of proof systems lies in <strong>proof logging</strong>, which is a technique used in combinatorial solvers to produce, alongside the output to a given problem, a proof that this output is correct. The generated proof is then verified by a separate <em>proof checker</em>, after which the correctness of the produced output is guaranteed. The importance of proof logging grows with the progress in solver technology. This progress makes solvers more efficient, but also more complicated, which sometimes results in the production of faulty outputs. Our proof system can be used to implement proof logging as well as a proof checker for solvers that use (non-stratified) inductive definitions, such as <a class=link href=https://wms.cs.kuleuven.be/dtai/pages/software/minisatid target=_blank rel=noopener>MinisatID</a>.</p><h2 id=how-is-it-done>How is it done?</h2><p>To obtain our proof system for general inductive definitions, we extended an existing proof system for inductive definitions by Brotherston and Simpson, based on the principle of <strong>mathematical induction</strong>. By mathematical induction, we mean a proof technique that is commonly taught in secondary school to prove theorems about the natural numbers. In it simplest form, mathematical induction for the natural numbers says the following: to prove that a certain property $P$ holds for every natural number $n$, it suffices to prove that the property holds for $0$ (the <strong>base case</strong>), and that if the property holds for a given number $x$, it also holds for $x+1$ (the <strong>induction step</strong>). In a formal proof system, this proof technique corresponds to the following <strong>inference rule</strong>:</p>\[
\begin{array}{c}
P(0) \qquad
P(x) \Rightarrow P(x+1) \\
\hline
N(n) \Rightarrow P(n)
\end{array}
\]<p>The formulas above the line are called the <strong>premises</strong>, and the formula below the line is called the <strong>conclusion</strong> of the rule. The inference rule says that if the base case and the induction step for $P$ (the premises) hold, then any natural number $n$ has property $P$ (the conclusion). Note that the premises of this inference rule are similar to the rules in the definition of the natural number predicate $N$ above. This is no coincidence. An alternative way of interpreting the natural number definition is by seeing $N$ as the <strong>smallest</strong> set that satisfies its defining rules. The inference rule above can also be read as saying that if $P$ is a set that satisfies the defining rules of $N$, then $N$ must be a subset of $P.$</p><p><img src=/p/a-sequent-calculus-for-general-inductive-definitions/figures/math_induction.png width=869 height=265 srcset="/p/a-sequent-calculus-for-general-inductive-definitions/figures/math_induction_hu_19ecfb3a45ca3a59.png 480w, /p/a-sequent-calculus-for-general-inductive-definitions/figures/math_induction_hu_6ef7c9b1478088a9.png 1024w" loading=lazy alt="Figure 5. The principle of mathematical induction on the natural numbers can be visualized by a sequence of falling dominoes. If domino 0 falls, and the fall of domino n entails the fall of domino n+1, then all dominoes fall." class=gallery-image data-flex-grow=327 data-flex-basis=787px></p><p>Sometimes the above method does not suffice, as it may be necessary to <strong>strengthen the induction hypothesis</strong>. For example, the following result cannot be proven with the above method:</p><blockquote><p><em>Fact.</em> For every natural number $n$, the sum of the first $n$ odd numbers is a perfect square. (A <em>perfect square</em> is a number that is equal to the square $m^2$ of a natural number $m$.)</p></blockquote><p>We can, however, use the above method to prove the following <strong>stronger</strong> result:</p><blockquote><p><em>Fact.</em> For every natural number $n$, the sum of the first $n$ odd numbers is equal to $n^2$.</p></blockquote><p>Thus, to prove a certain property $P$ of the natural numbers, one generally needs to find another property for which the method of mathematical induction works and which implies $P$. This stronger property is called the <strong>induction hypothesis</strong>. There is no general method to find a suitable induction hypothesis, so applying this proof technique usually requires some creativity. Letting $F$ denote the induction hypothesis, this proof technique corresponds to the following inference rule:</p>\[
\begin{array}{c}
F(0) \qquad
F(x) \Rightarrow F(x+1) \qquad
F(n) \Rightarrow P(n) \\
\hline
N(n) \Rightarrow P(n)
\end{array}
\]<p>The above proof method does not only work for the natural numbers, but in fact for <strong>any</strong> object that can be defined inductively, or at least through a positive definition (i.e., without negation). The proof system of Brotherston and Simpson does not support definitions with negation, which is very restrictive compared to FO(ID). Adding negation to definitions makes things significantly trickier. As an example, consider the following definition of the odd number predicate $O$:</p>\[ \left\{ \begin{array}{l}
\forall x: O(x+1) \leftarrow \lnot O(x)
\end{array} \right\}
\]<p>It differs from the even number definition in that it does not have a rule saying that $0$ is odd. If we were to straightforwardly extend the inference rule we had for the natural numbers to this definition, it would look as follows:</p>\[
\begin{array}{c}
\lnot F(x) \Rightarrow F(x+1) \qquad
F(n) \Rightarrow P(n) \\
\hline
O(n) \Rightarrow P(n)
\end{array}
\]<p>The left premise says that the induction hypothesis $F$ satisfies the defining rule of $O$, and the right premise says that it implies the property $P$ that we want to prove for the odd numbers. This is not a good inference rule, however, as it is <strong>not sound</strong>, meaning that it can <strong>derive false statements</strong>! For instance, letting $F$ and $P$ be the even number predicate $E$, we could derive that any odd number is also an even number, which is of course wrong. The underlying reason is that an induction hypothesis generally holds for <strong>more</strong> objects than those contained in the defined predicate. Hence, the negation of an induction hypothesis generally holds for <strong>less</strong> objects than those not contained in the defined predicate. Therefore, the negation of an induction hypothesis is too strong of an assumption for non-members of the defined predicate.</p><p>Our solution to this problem is surprisingly easy. We simply replace the formula $\lnot F(x)$ in the left premise by the formula $\lnot O(x)$:</p>\[
\begin{array}{c}
\lnot O(x) \Rightarrow F(x+1) \qquad
F(n) \Rightarrow P(n) \\
\hline
O(n) \Rightarrow P(n)
\end{array}
\]<p>As a recapitulation, $O$ represents the inductively defined concept in this example, $P$ is a property to be proven about the inductively defined concept $O$, and $F$ is the induction hypothesis, a property that should imply $P$. This inference rule allows us to prove all kinds of properties of odd numbers, such as the fact that every odd number is the successor (or predecessor) of an even number, for example.</p><p>Our solution may seem naïve, but we have shown that this proof technique is sound for general non-stratified definitions, and it appears strong enough to prove many theorems about non-stratified definitions.</p><h2 id=what-is-next>What is next?</h2><p>So far, we have only presented the proof system itself, applied it to a few examples of non-stratified definitions, and shown that it is sound. Soundness is a minimal property for a proof system to have, as it means that its inference rules can only derive true statements. A first direction for further research is therefore to <strong>show extra theoretical properties that give further insight into the system</strong>, e.g., in how powerful the system is.</p><p>A second idea would be to <strong>develop a cyclic proof system for non-stratified definitions</strong>, extending another proof system by Brotherston and Simpson. In a <strong>cyclic proof system</strong>, proofs no longer take the form of trees but of general graphs, which may contain cycles. This makes the structure of proofs more complex, but it trades off against the complexity of the inference rules themselves. In particular, <strong>cyclic proofs can circumvent the principle of mathematical induction</strong> and therefore, it is no longer necessary to creatively guess a good induction hypothesis.</p><p>Third, we can <strong>extend the obtained proof system to a more powerful system</strong> that can reason about even more complex information by <strong>incorporating additional language constructs</strong>, such as partial functions, modal operators, aggregates, etc.</p><p>Finally, our sequent calculus can be used as the basis of a <strong>proof assistant</strong> that can aid humans in proving theorems about general inductive definitions, and it can be used to extend combinatorial solvers that use inductive definitions such as MinisatID with <strong>proof logging</strong> algorithms.</p><p>In conclusion, we have <strong>established a promising framework for doing formal proofs about general inductive definitions</strong>, providing certainty and explainability for complex forms of knowledge.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/proofs/>Proofs</a>
<a href=/tags/inductive-definitions/>Inductive Definitions</a>
<a href=/tags/sequent-calculus/>Sequent Calculus</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=[".main-article",".widget--toc"];e.forEach(e=>{const t=document.querySelector(e);t&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})})</script></article><script src=https://giscus.app/client.js data-repo=dmkoder/blogic-comments data-repo-id=R_kgDOQLwBtQ data-category=General data-category-id=DIC_kwDOQLwBtc4CxO_1 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=noborder_light data-lang=en data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"noborder_light":"noborder_gray")}})()</script><footer class=site-footer><section class=copyright>&copy;
2025 -
2026 bLogic.ink</section><section class=powerby>Ink and Think!<br>We don’t use cookies. We do use <a href=https://www.goatcounter.com/ target=_blank>GoatCounter</a>, a privacy-friendly open-source analytics tool, to understand which posts are getting attention. If you’re using an ad blocker, please consider disabling it for this site—otherwise the counter might not register your visit.<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.34.1>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>